%%%===================================================================
%%% @author Mathieu Kerjouan <contact at erlang-punch.com>
%%%
%%% @doc `nostrlib' contains all functions commonly used by relays and
%%% clients. This is a low level interface and should not be directly
%%% used.
%%%
%%% This module provides all functions to convert hexadecimal strings
%%% to integer or bitstring. only lowercase hexadecimal strings are
%%% accepted.
%%%
%%% == Examples ==
%%%
%%% A raw JSON message can be decoded using `nostrlib:decode/1'
%%% function. By default, every element of the message is checked and
%%% a list of label is created containing the information generated by
%%% the parser. For example, if a message has not a strict id like
%%% defined by NIP/01, a label will be added saying so.
%%%
%%% ```
%%% {ok, DecodedMessage, Labels} = nostrlib:decode(Message).
%%% {ok, DecodedMessage, Labels} = nostrlib:decode(Message, Opts).
%%% '''
%%%
%%% The `nostrlib:encode/1' function can be used to encode a nostr
%%% record to its JSON format.
%%%
%%% ```
%%% {ok, EncodedMessage} = nostrlib:encode(Event).
%%% {ok, EncodedMessage} = nostrlib:encode(Event, Opts).
%%% '''
%%%
%%% If the event id or the signature is missing, the encoding function
%%% will try to generate it or return an error with the reason.
%%%
%%% @todo create encode/1 function
%%% @todo create decode/1 function
%%% @end
%%%===================================================================
-module(nostrlib).
-export([decode/1, decode/2]).
-export([encode/1, encode/2]).
-export([check/1, check/2]).
-export([verify/1, verify/3]).
-export([sign/2]).
-export([integer_to_hex/1, hex_to_integer/1]).
-export([binary_to_hex/1, hex_to_binary/1]).
-export([create_signature/2]).
-export([check_hex/1, is_hex/1]).
-export([new_subscription_id/0]).
-include_lib("eunit/include/eunit.hrl").
-include("nostrlib.hrl").

%%--------------------------------------------------------------------
%% extra-specification to deal with eunit.
%%--------------------------------------------------------------------
-spec test() -> any().

%%--------------------------------------------------------------------
%% @doc `encode/1' converts a nostr record messages into nostr JSON
%% format.
%%
%% @see encode/2
%% @end
%%--------------------------------------------------------------------
-spec encode(Message) -> Return when
      Message :: decoded_message(),
      Return :: encoded_event().

encode(Message) ->
    encode(Message, []).

%%--------------------------------------------------------------------
%% @doc `encode/2' converts a nostr record message into nostr JSON
%% data.
%%
%% This function is mainly used to low level communication with the
%% relays or the servers but can help developers or users to create
%% customer payload. Some rules are applied though.
%%
%% <li>the record must be valid with raw values in it</li>
%% <li>a private key needs to be passed if the signature is not already present</li>
%% <li>if a value is not defined it will be automatically be created if possible</li>
%%
%% == Examples ==
%%
%% ```
%% % load the records from nostrlib library
%% rr(nostrlib).
%%
%% % encode an event
%% nostrlib:encode(#event{ kind = set_metadata, content = <<>>}
%%                ,[{private_key, PrivateKey}]).
%%
%%
%% '''
%%
%% @todo add examples
%% @todo add support to return record instead of bitstring.
%% @end
%%--------------------------------------------------------------------
-spec encode(Message, Opts) -> Return when
      Message :: message(),
      Opts :: [ {private_key, <<_:256>>}
              | {as_record, boolean()}
              ],
      Return :: iodata() | decoded_message().

encode(#event{} = Event, Opts) ->
    case encode_event(Event, Opts) of
        {ok, [<<"EVENT">>|_] = Encoded} -> {ok, to_json(Encoded)};
        {ok, #event{} = Encoded} -> {ok, Encoded};
        Elsewise -> Elsewise
    end;
encode(#subscription{} = Subscription, Opts) ->
    case encode_subscription(Subscription, Opts) of
        {ok, Encoded} -> {ok, to_json(Encoded)};
        Elsewise -> Elsewise
    end;
encode(#request{} = Request, Opts) ->
    case encode_request(Request, Opts) of
        {ok, Encoded} -> {ok, to_json(Encoded)};
        Elsewise -> Elsewise
    end;
encode(#close{} = Close, Opts) ->
    case encode_close(Close, Opts) of
        {ok, Encoded} -> {ok, to_json(Encoded)};
        Elsewise -> Elsewise
    end;
encode(#notice{} = Notice, Opts) ->
    case encode_notice(Notice, Opts) of
        {ok, Encoded} -> {ok, to_json(Encoded)};
        Elsewise -> Elsewise
    end;
encode(#eose{} = EOSE, Opts) ->
    case encode_eose(EOSE, Opts) of
        {ok, Encoded} -> {ok, to_json(Encoded)};
        Elsewise -> Elsewise
    end;
encode(_, _) ->
    {error, [{encode, unsupported}]}.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_request(#request{ subscription_id = undefined }, _Opts) ->
    {error, [{subscription_id, undefined}]};
encode_request(#request{ subscription_id = <<SubscriptionId/bitstring>>
                       , filter = Filter } = _Request, _Opts)
  when is_list(Filter) orelse is_record(Filter, filter) ->
    case encode_filters(Filter) of
        {ok, []} ->
            {error, [{filter, []}]};
        {ok, F} when F =:= #{} ->
            {error, [{filter, #{}}]};
        {ok, F} ->
            {ok, [<<"REQ">>, SubscriptionId, F]};
        Elsewise -> Elsewise
    end;
encode_request(#request{ subscription_id = SubscriptionId}, _Opts) ->
    {error, [{subscription_id, SubscriptionId}]}.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_filters(#filter{} = Filter) ->
    encode_filter(Filter);
encode_filters(Filters)
  when is_list(Filters) ->
    encode_filters(Filters, []).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filters([], Buffer) -> {ok, lists:reverse(Buffer)};
encode_filters([Filter|Rest], Buffer) ->
    case encode_filter(Filter) of
        {ok, F} -> encode_filters(Rest, [F|Buffer]);
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter(Filter) ->
    encode_filter_ids(Filter, #{}).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_ids(#filter{ event_ids = EventIds } = Filter, Buffer)
  when EventIds =:= [] orelse EventIds =:= undefined ->
    encode_filter_authors(Filter, Buffer);
encode_filter_ids(#filter{ event_ids = EventIds } = Filter, Buffer) ->
    case encode_prefixes(EventIds) of
        {ok, E} ->
            Next = Buffer#{ <<"ids">> => E },
            encode_filter_authors(Filter, Next);
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_authors(#filter{ authors = Authors } = Filter, Buffer)
  when Authors =:= [] orelse Authors =:= undefined ->
    encode_filter_kinds(Filter, Buffer);
encode_filter_authors(#filter{ authors = Authors } = Filter, Buffer) ->
    case encode_prefixes(Authors) of
        {ok, A} ->
            Next = Buffer#{ <<"authors">> => A },
            encode_filter_kinds(Filter, Next);
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_prefixes(Prefixes) ->
    encode_prefixes(Prefixes, []).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_prefixes([], Buffer) -> {ok, lists:reverse(Buffer)};
encode_prefixes([<<Prefix/bitstring>>|Rest], Buffer) ->
    case Prefix of
        _ when bit_size(Prefix) < 32 -> {error, [{prefix, Prefix}]};
        _ when bit_size(Prefix) > 256 -> {error, [{prefix, Prefix}]};
        _ ->
            Encoded = binary_to_hex(Prefix),
            encode_prefixes(Rest, [Encoded|Buffer])
    end;
encode_prefixes(Prefixes,_) ->
    {error, [{prefixes, Prefixes}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_kinds(#filter{ kinds = Kinds } = Filter, Buffer)
  when Kinds =:= [] orelse Kinds =:= undefined ->
    encode_filter_tag_event_ids(Filter, Buffer);
encode_filter_kinds(#filter{ kinds = Kinds } = Filter, Buffer) ->
    Encoded = kinds(Kinds),
    Next = Buffer#{ <<"kinds">> => Encoded },
    encode_filter_tag_event_ids(Filter, Next).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_tag_content(Content) ->
    encode_filter_tag_content(Content, []).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_tag_content([], Buffer) -> {ok, lists:reverse(Buffer)};
encode_filter_tag_content([<<Content:256/bitstring>>|Rest], Buffer) ->
    Encoded = binary_to_hex(Content),
    encode_filter_tag_content(Rest, [Encoded|Buffer]);
encode_filter_tag_content(Content, _) ->
    {error, [{content, Content}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_tag_event_ids(#filter{ tag_event_ids = TagEventIds } = Filter, Buffer)
  when TagEventIds =:= [] orelse TagEventIds =:= undefined ->
    encode_filter_tag_public_keys(Filter, Buffer);
encode_filter_tag_event_ids(#filter{ tag_event_ids = EventIds } = Filter, Buffer)
  when is_list(EventIds) ->
    case encode_filter_tag_content(EventIds) of
        {ok, E} ->
            Next = Buffer#{ <<"#e">> => E },
            encode_filter_tag_public_keys(Filter, Next);
        Elsewise -> Elsewise
    end;
encode_filter_tag_event_ids(#filter{ tag_event_ids = T }, _) ->
    {error, {tag_event_ids, T}}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_tag_public_keys(#filter{ tag_public_keys = PublicKeys } = Filter, Buffer)
  when PublicKeys =:= [] orelse PublicKeys =:= undefined ->
    encode_filter_since(Filter, Buffer);
encode_filter_tag_public_keys(#filter{ tag_public_keys = PublicKeys } = Filter, Buffer)
  when is_list(PublicKeys) ->
    case encode_filter_tag_content(PublicKeys) of
        {ok, P} ->
            Next = Buffer#{ <<"#p">> => P },
            encode_filter_since(Filter, Next);
        Elsewise -> Elsewise
    end;
encode_filter_tag_public_keys(#filter{ tag_event_ids = T }, _) ->
    {error, {tag_public_keys, T}}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_since(#filter{ since = Since } = Filter, Buffer)
  when Since =:= undefined ->
    encode_filter_until(Filter, Buffer);
encode_filter_since(#filter{ since = {{_,_,_},{_,_,_}} = Since } = Filter, Buffer) ->
    Timestamp = erlang:universaltime_to_posixtime(Since),
    Next = Buffer#{ <<"since">> => Timestamp },
    encode_filter_until(Filter, Next);
encode_filter_since(#filter{ since = Since }, _Buffer) ->
    {error, [{since, Since}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_until(#filter{ until = Until } = Filter, Buffer)
  when Until =:= undefined ->
    encode_filter_limit(Filter, Buffer);
encode_filter_until(#filter{ until = {{_,_,_},{_,_,_}} = Until } = Filter, Buffer) ->
    Timestamp = erlang:universaltime_to_posixtime(Until),
    Next = Buffer#{ <<"until">> => Timestamp },
    encode_filter_limit(Filter, Next);
encode_filter_until(#filter{ until = Until }, _Buffer) ->
    {error, [{until, Until}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_filter_limit(#filter{ limit = Limit } = _Filter, Buffer)
  when Limit =:= undefined ->
    {ok, Buffer};
encode_filter_limit(#filter{ limit = Limit } = _Filter, Buffer)
  when is_integer(Limit) andalso Limit > 0 ->
    Next = Buffer#{ <<"limit">> => Limit },
    {ok, Next};
encode_filter_limit(#filter{ limit = Limit}, _Buffer) ->
    {error, [{limit, Limit}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec encode_filters_test() -> any().
encode_filters_test() ->
    [?assertEqual({ok, #{}}, encode_filters(#filter{}))
    ,?assertEqual({ok, #{ <<"limit">> => 10 }}
                 ,encode_filters(#filter{ limit = 10 }))
    ,?assertEqual({ok, #{ <<"since">> => 1577840461}}
                 ,encode_filters(#filter{ since = {{2020,01,01},{01,01,01}} }))
    ,?assertEqual({ok, #{ <<"until">> => 1577840461}}
                 ,encode_filters(#filter{ until = {{2020,01,01},{01,01,01}} }))
    ,?assertEqual({ok, #{ <<"kinds">> => [0,1] }}
                 ,encode_filters(#filter{ kinds = [set_metadata, text_note] }))
    ].

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_eose(#eose{ id = undefined }, _Opts) ->
    {error, [{id, undefined}]};
encode_eose(#eose{ id = <<Id/bitstring>> }, _Opts) ->
    {ok, [<<"EOSE">>, Id]}.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_subscription(#subscription{ id = undefined }, _Opts) ->
    {error, [{id, undefined}]};
encode_subscription(#subscription{ content = undefined }, _Opts) ->
    {error, [{content, undefined}]};
encode_subscription(#subscription{ content = <<>> }, _Opts) ->
    {error, [{content, undefined}]};
encode_subscription(#subscription{ content = Content }, _Opts)
  when not is_bitstring(Content) andalso not is_record(Content, event) ->
    {error, [{content, Content}]};
encode_subscription(#subscription{ id = Id
                                 , content = #event{} = Content
                                 }, Opts) ->
    case encode_event(Content, Opts) of
        {ok, [<<"EVENT">>, Rest]} ->
            {ok, [<<"EVENT">>, Id, Rest]};
        Elsewise -> Elsewise
    end;
encode_subscription(#subscription{ id = Id
                                 , content = <<Content/bitstring>>
                                 }, Opts) ->
    case thoas:decode(Content) of
        {ok, Json} ->
            case check([<<"EVENT">>, Json], Opts) of
                {ok, [<<"EVENT">>, Event]} ->
                    {ok, [<<"EVENT">>, Id, Event]};
                {ok, Event} when is_map(Event) ->
                    {ok, [<<"EVENT">>, Id, Event]};
                Elsewise -> Elsewise
            end;
        Elsewise ->
            Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_notice(#notice{ message = undefined }, _Opts) ->
    {error, [{message, undefined}]};
encode_notice(#notice{ message = <<Message/bitstring>> }, _Opts) ->
    {ok, [<<"NOTICE">>, Message]};
encode_notice(#notice{ message = Message }, _Opts) ->
    {error, [{message, Message}]}.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_close(#close{ subscription_id = undefined }, _) ->
    {error, [{subscription_id, undefined}]};
encode_close(#close{ subscription_id = <<SubscriptionId/bitstring>>}, _)
  when is_bitstring(SubscriptionId) ->
    {ok, [<<"CLOSE">>, SubscriptionId]};
encode_close(#close{ subscription_id = SubscriptionId }, _) ->
    {error, [{subscription_id, SubscriptionId}]}.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_event(Event, Opts) ->
    encode_event_content(Event, Opts, #{}).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_content(#event{ content = undefined }, _Opts, _Buffer) ->
    {error, [{content, undefined}]};
encode_event_content(#event{ content = Content} = Event, _Opts, Buffer)
  when is_bitstring(Content) ->
    Next = Buffer#{ <<"content">> => Content },
    encode_event_kind(Event, _Opts, Next);
encode_event_content(#event{ content = Content}, _Opts, _Buffer) ->
    {error, [{content, Content}]}.

% @hidden
-spec encode_event_content_test() -> any().
encode_event_content_test() ->
    [?assertEqual({error, [{content, undefined}]}
                 ,encode_event_content(#event{ content = undefined }, [], <<>>))
    ,?assertEqual({error, [{content, []}]}
                 ,encode_event_content(#event{ content = [] }, [], <<>>))
    ].

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_kind(#event{ kind = undefined }, _Opts, _Buffer) ->
    {error, [{kind, undefined}]};
encode_event_kind(#event{ kind = Kind } = Event, Opts, Buffer)
  when is_atom(Kind) ->
    Next = Buffer#{ <<"kind">> => kind(Kind) },
    encode_event_tags(Event, Opts, Next);
encode_event_kind(#event{ kind = Kind }, _, _) ->
    {error, [{kind, Kind}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_tags(#event{ tags = Undef } = Event, Opts, Buffer)
  when Undef =:= [] orelse Undef =:= undefined ->
    Next = Buffer#{ <<"tags">> => [] },
    encode_event_created_at(Event, Opts, Next);
encode_event_tags(#event{ tags = Tags} = Event, Opts, Buffer)
  when is_list(Tags) ->
    case encode_tags(Tags) of
        {ok, T} ->
            Next = Buffer#{ <<"tags">> => T },
            encode_event_created_at(Event, Opts, Next);
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
% @todo add support for 64bits unix timestamp
encode_event_created_at(#event{ created_at = undefined } = Event, Opts, Buffer) ->
    CreatedAt = erlang:system_time(seconds),
    UniversalTime = erlang:posixtime_to_universaltime(CreatedAt),
    NextEvent = Event#event{ created_at = UniversalTime },
    Next = Buffer#{ <<"created_at">> => CreatedAt },
    encode_event_public_key(NextEvent, Opts, Next);
encode_event_created_at(#event{ created_at = {{_,_,_},{_,_,_}} = CreatedAt } = Event, Opts, Buffer) ->
    Next = Buffer#{ <<"created_at">> => erlang:universaltime_to_posixtime(CreatedAt) },
    encode_event_public_key(Event, Opts, Next);
encode_event_created_at(#event{ created_at = CreatedAt } = _Event, _Opts, _Buffer) ->
    {error, [{created_at, CreatedAt}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_public_key(#event{ public_key = undefined } = Event, Opts, Buffer) ->
    case proplists:get_value(private_key, Opts, undefined) of
        undefined ->
            {error, [{public_key, undefined}, {private_key, undefined}]};
        <<PrivateKey:256/bitstring>> ->
            {ok, PublicKey} = nostrlib_schnorr:new_publickey(PrivateKey),
            Next = Buffer#{ <<"pubkey">> => binary_to_hex(PublicKey) },
            Event2 = Event#event{ public_key = PublicKey },
            encode_event_id(Event2, Opts, Next);
        <<PrivateKey/bitstring>> ->
            {error, [{private_key, PrivateKey}]};
        _ ->
            {error, [{private_key, undefined}]}
    end;
encode_event_public_key(#event{ public_key = <<PublicKey:256/bitstring>> } = Event, Opts, Buffer) ->
    Next = Buffer#{ <<"pubkey">> => binary_to_hex(PublicKey) },
    encode_event_id(Event, Opts, Next);
encode_event_public_key(#event{ public_key = <<PublicKey/bitstring>>}, _Opts, _Buffer) ->
    {error, [{public_key, PublicKey}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_id(#event{ id = undefined } = Event, Opts, Buffer) ->
    case create_id(Buffer) of
        {ok, Id} ->
            NextEvent = Event#event{ id = hex_to_binary(Id) },
            Next = Buffer#{ <<"id">> => Id },
            encode_event_signature(NextEvent, Opts, Next);
        Elsewise -> Elsewise
    end;
encode_event_id(#event{ id = <<Id:256/bitstring>> } = Event, Opts, Buffer) ->
    Next = Buffer#{ <<"id">> => binary_to_hex(Id) },

    encode_event_signature(Event, Opts, Next);
encode_event_id(#event{ id = Id }, _Opts, _Buffer) ->
    {error, [{event_id, Id}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_signature(#event{ signature = undefined } = Event, Opts, #{ <<"id">> := Id } = Buffer) ->
    case proplists:get_value(private_key, Opts, undefined) of
        undefined -> {error, [{private_key, undefined}]};
        <<PrivateKey:256/bitstring>> ->
            {ok, Signature} = create_signature(Id, PrivateKey),
            NextEvent = Event#event{ signature = Signature },
            Next = Buffer#{ <<"sig">> => binary_to_hex(Signature) },
            encode_event_final(NextEvent, Opts, Next)
    end;
encode_event_signature(#event{ signature = <<Signature:512/bitstring>> } = Event, Opts, Buffer) ->
    case verify(Event) of
        true ->
            Next = Buffer#{ <<"sig">> => binary_to_hex(Signature) },
            encode_event_final(Event, Opts, Next);
        false ->
            {error, [{signature, Signature}]}
    end;
encode_event_signature(#event{ signature = Signature }, _Opts, _Buffer) ->
    {error, [{signature, Signature}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
encode_event_final(Event, Opts, Buffer) ->
    case proplists:get_value(as_record, Opts, false) of
        false ->
            {ok, [<<"EVENT">>, Buffer]};
        true ->
            {ok, Event}
    end.

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_tags(Tags) ->
    encode_tags(Tags, []).

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_tags(Tags, Opts) ->
    encode_tags(Tags, Opts, []).

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
encode_tags([], _, Buffer) ->
    {ok, lists:reverse(Buffer)};
encode_tags([Tag|Rest], Opts, Buffer) ->
    case encode_tag(Tag, Opts) of
        {ok, T} -> encode_tags(Rest, Opts, [T|Buffer]);
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec encode_tags_test() -> any().
encode_tags_test() ->
    BinKey1 = <<1:256>>,
    HexKey1 = <<(<< <<"0">> || _ <- lists:seq(0,62) >>)/bitstring, "1">>,
    BinKey2 = <<2:256>>,
    HexKey2 = <<(<< <<"0">> || _ <- lists:seq(0,62) >>)/bitstring, "2">>,
    BinKey3 = <<3:256>>,
    HexKey3 = <<(<< <<"0">> || _ <- lists:seq(0,62) >>)/bitstring, "3">>,
    [?assertEqual({ok, [[<<"p">>, HexKey1]
                       ,[<<"p">>, HexKey2]
                       ,[<<"e">>, HexKey3]]}
                 ,encode_tags([#tag{ name = public_key, value = BinKey1 }
                              ,#tag{ name = public_key, value = BinKey2 }
                              ,#tag{ name = event_id, value = BinKey3 }
                              ])
                 )
    ].

%%--------------------------------------------------------------------
%% @hidden
%% @doc
%% @end
%%--------------------------------------------------------------------
encode_tag(#tag{ name = public_key, value = PublicKey, params = []}, _Opts) ->
    {ok, [<<"p">>, binary_to_hex(PublicKey)]};
encode_tag(#tag{ name = public_key, value = PublicKey, params = Params}, _Opts) ->
    {ok, [<<"p">>, binary_to_hex(PublicKey)] ++ Params};
encode_tag(#tag{ name = event_id, value = EventId, params = []}, _Opts) ->
    {ok, [<<"e">>, binary_to_hex(EventId)]};
encode_tag(#tag{ name = event_id, value = EventId, params = Params}, _Opts) ->
    {ok, [<<"e">>, binary_to_hex(EventId)] ++ Params};
encode_tag(#tag{ name = EventName, value = Value, params = Params }, _Opts) ->
    {error, [{tag, EventName},{value, Value},{params, Params}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec encode_tag_test() -> any().
encode_tag_test() ->
    BinKey = <<1:256>>,
    HexKey = <<(<< <<"0">> || _ <- lists:seq(0,62) >>)/bitstring, "1">>,
    [?assertEqual({ok, [<<"p">>, HexKey]}
                 ,encode_tag(#tag{ name = public_key, value = BinKey}, [])
                 )
    ,?assertEqual({ok, [<<"p">>, HexKey, <<"wss://relay">>]}
                 ,encode_tag(#tag{ name = public_key, value = BinKey, params = [<<"wss://relay">>]}, [])
                 )
    ,?assertEqual({ok, [<<"e">>, HexKey]}
                 ,encode_tag(#tag{ name = event_id, value = BinKey}, [])
                 )
    ,?assertEqual({ok, [<<"e">>, HexKey, <<"wss://relay">>]}
                 ,encode_tag(#tag{ name = event_id, value = BinKey, params= [<<"wss://relay">>]}, [])
                 )
     ].

%%--------------------------------------------------------------------
%% @hidden
%% @doc
%% @end
%%--------------------------------------------------------------------
to_json(Map) ->
    thoas:encode(Map).

%%--------------------------------------------------------------------
%% @doc `decode/1'
%%
%% @see decode/2
%% @end
%%--------------------------------------------------------------------
-spec decode(Message) -> Return when
      Message :: encoded_event(),
      Return :: decoded_messages().
decode(Message) ->
    decode(Message, []).

%%--------------------------------------------------------------------
%% @doc `decode/2'
%% @end
%%--------------------------------------------------------------------
-spec decode(Message, Opts) -> Return when
      Message :: encoded_event(),
      Opts :: proplists:proplists(),
      Return :: decoded_messages().

decode(Json, _Opts)
  when is_map(Json) orelse is_list(Json) ->
    decode_message(Json);
decode(<<Message/bitstring>>, _Opts) ->
    case thoas:decode(Message) of
        {ok, Json} ->
            decode_message(Json);
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @doc `check/1'
%%
%% @see check/2
%% @end
%%--------------------------------------------------------------------
-spec check(Event) -> Return when
      Event :: encoded_event(),
      Return :: {ok, Event}
              | {error, any()}.

check(Message) ->
    check(Message, []).

%%--------------------------------------------------------------------
%% @doc `check/2' checks and returns the content based on the
%% specification, without returning the labels and without decoding
%% the input.
%%
%% == Examples ==
%%
%% ```
%% '''
%%
%% @end
%%--------------------------------------------------------------------
-spec check(Event, Opts) -> Return when
      Event :: encoded_event(),
      Opts :: proplists:proplists(),
      Return :: {ok, Event}
              | {error, any()}.

check(Message, Opts) ->
    case decode(Message, Opts) of
        {ok, _, _} -> {ok, Message};
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @doc internal function used to decode every element of a JSON
%% encoded message and convert it to record.
%%
%% @todo creates more test.
%% @end
%%--------------------------------------------------------------------
-spec decode_message(Json) -> Return when
      Json :: term(),
      Return :: {ok, term()}
              | {error, proplists:proplists()}.

% decode an event message from client to relay
decode_message([<<"EVENT">>, Event])
  when is_map(Event) ->
    decode_event_id(Event, #event{}, []);

% decode an event message from relay to client
decode_message([<<"EVENT">>, <<SubscriptionId/bitstring>>, Event])
  when is_map(Event) ->
    decode_subscription(SubscriptionId, Event, []);

% decode a subscription request
decode_message([<<"REQ">>, <<SubscriptionId/bitstring>>, Filter]) ->
    decode_request(SubscriptionId, Filter, []);

% decode a close message: end of subscription request
decode_message([<<"CLOSE">>, SubscriptionId]) ->
    decode_close(SubscriptionId, []);

% decode a notice message
decode_message([<<"NOTICE">>, Notice]) ->
    decode_notice(Notice, []);

% decode an end of subscription message
decode_message([<<"EOSE">>, SubscriptionId]) ->
    decode_eose(SubscriptionId, []);

decode_message(Message) ->
    {error, {unsupported, Message}}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_id(#{ <<"id">> := <<RawEventId/bitstring>> } = Rest, Buffer, Labels)
  when byte_size(RawEventId) =:= 64 ->
    case is_hex(RawEventId) of
        true ->
            EventId = hex_to_binary(RawEventId),
            Next = Buffer#event{ id = EventId },
            decode_event_pubkey(Rest, Next, Labels);
        false ->
            {error, [{event, {bad, id}}]}
    end;
decode_event_id(#{ <<"id">> := <<_/bitstring>> }, _, Labels) ->
    Reason = [{event, {bad, id}}
             ,{labels, Labels}
             ],
    {error, Reason};
decode_event_id(_, _, _) ->
    Reason = [{event, {missing, id}}],
    {error, Reason}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_pubkey(#{ <<"pubkey">> := <<RawPublicKey/bitstring>> } = Rest, Buffer, Labels)
  when byte_size(RawPublicKey) =:= 64 ->
    case is_hex(RawPublicKey) of
        true ->
            PublicKey = hex_to_binary(RawPublicKey),
            Next = Buffer#event{ public_key = PublicKey },
            decode_event_created_at(Rest, Next, Labels);
        false ->
            {error, [{event, {bad, public_key}}]}
    end;
decode_event_pubkey(#{ <<"pubkey">> := <<_/bitstring>> }, _, _) ->
    {error, [{event, {bad, public_key}}]};
decode_event_pubkey(_, _, _) ->
    {error, [{event, {missing, pubkey}}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_created_at(#{ <<"created_at">> := RawCreatedAt } = Rest, Buffer, Labels)
  when is_integer(RawCreatedAt) ->
    CreatedAt = erlang:posixtime_to_universaltime(RawCreatedAt),
    Next = Buffer#event{ created_at = CreatedAt },
    decode_event_kind(Rest, Next, Labels);
decode_event_created_at(_,_,_) ->
    {error, [{event, {missing, created_at}}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_kind(#{ <<"kind">> := RawKind } = Rest, Buffer, Labels)
  when is_integer(RawKind) ->
    case kind(RawKind) of
        unsupported -> {error, [{event, {unsupported, kind}}]};
        Kind ->
            Next = Buffer#event{ kind = Kind },
            decode_event_tags(Rest, Next, Labels)
    end;
decode_event_kind(_,_,_) ->
    {error, [{event, {missing, kind}}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_tags(#{ <<"tags">> := RawTags } = Rest, Buffer, Labels)
  when is_list(RawTags) ->
    case decode_tags(RawTags) of
        {ok, Tags} ->
            Next = Buffer#event{ tags = Tags },
            decode_event_content(Rest, Next, Labels);
        Elsewise -> Elsewise
    end;
decode_event_tags(_,_,_) ->
    {error, [{event, {missing, tags}}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_content(#{ <<"content">> := Content } = Rest, Buffer, Labels)
  when is_binary(Content) ->
    Next = Buffer#event{ content = Content },
    decode_event_signature(Rest, Next, Labels);
decode_event_content(_,_,_) ->
    {error, [{event, {missing, content}}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_event_signature(#{ <<"sig">> := <<RawSignature/binary>> } = Rest, Buffer, Labels)
  when byte_size(RawSignature) =:= 128 ->
    case is_hex(RawSignature) of
        true ->
            Signature = hex_to_binary(RawSignature),
            Next = Buffer#event{ signature = Signature },
            decode_check_event_id(Rest, Next, Labels);
        false ->
            Reason = [{reason, bad_signature}
                     ,{payload, Rest}
                     ,{structure, Buffer}
                     ,{labels, Labels}
                     ],
            {error, Reason}
    end;
decode_event_signature(Rest, Buffer, Labels) ->
    Reason = [{reason, missing_signature}
             ,{payload, Rest}
             ,{structure, Buffer}
             ,{labels, Labels}
             ],
    {error, Reason}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_check_event_id(#{ <<"id">> := Id } = Rest, Buffer, Labels) ->
    case {ok, Id} =:= create_id(Rest) of
        true ->
            decode_check_signature(Rest, Buffer, [{has_strict_event_id, true}|Labels]);
        false ->
            decode_check_signature(Rest, Buffer, [{has_strict_event_id, false}|Labels])
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_check_signature(Rest, Buffer, Labels) ->
    case verify(Rest) of
        true ->
            {ok, Buffer, [{has_valid_signature, true}|Labels]};
        false ->
            Reason = [{reason, signature}
                     ,{payload, Rest}
                     ,{structure, Buffer}
                     ,{labels, [{has_valid_signature, false}|Labels]}
                     ],
            {error, Reason}
    end.

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
%% create_id(#event{} = Event) ->
%%     Serialized = serialize(Event),
%%     {ok, crypto:hash(sha256, Serialized)};
create_id(Event) 
  when is_map(Event) ->
    case serialize(Event) of
        {ok, Serial} ->
            RawId = crypto:hash(sha256, Serial),
            {ok, binary_to_hex(RawId)};
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @doc `create_signature/2' creates a signature based on an event id
%% and a private key. It returns a raw bin.
%%
%% This function accepts both hexadecimal format and binary format. It
%% will output always a binary format.
%%
%% == Examples ==
%%
%% ```
%% Binary = <<1:256>>.
%% Hex = << <<"1">> || _ <- lists:seq(0,63) >>.
%%
%% Signature = create_signature(Binary, Binary).
%% Signature = create_signature(Binary, Hex).
%% Signature = create_signature(Hex, Binary).
%% Signature = create_signature(Hex, Hex).
%% '''
%%
%% @end
%% --------------------------------------------------------------------
-spec create_signature(EventId, PrivateKey) -> Return when
      EventId :: decoded_event_id(),
      PrivateKey :: decoded_private_key(),
      Return :: {ok, decoded_signature()}
              | {error, proplists:proplists()}.

create_signature(<<Id/binary>>, <<PrivateKey/binary>>) ->
    case {is_hex(Id), is_hex(PrivateKey)} of
        {true, true} ->
            BinId = hex_to_binary(Id),
            BinPrivateKey = hex_to_binary(PrivateKey),
            nostrlib_schnorr:sign(BinId, BinPrivateKey);
        {false, true} ->
            BinPrivateKey = hex_to_binary(PrivateKey),
            nostrlib_schnorr:sign(Id, BinPrivateKey);
        {true, false} ->
            BinId = hex_to_binary(Id),
            nostrlib_schnorr:sign(BinId, PrivateKey);
        {false, false} ->
            nostrlib_schnorr:sign(Id, PrivateKey)
    end.

% @hidden
-spec create_signature_test() -> any().
create_signature_test() ->
    Bin = <<1:256>>,
    Head = << <<"0">> || _ <- lists:seq(0,62) >>,
    Hex = <<Head/bitstring, "1">>,
    Signature = <<106,173,19,98,223,201,254,15,199,209,119,83,34,226
                 ,82,65,104,146,115,163,202,32,2,58,203,186,161,191
                 ,248,192,30,206,174,71,86,28,235,92,115,214,198,59
                 ,87,188,119,104,171,1,101,141,142,41,156,37,57,40
                 ,210,191,40,114,92,0,166,1>>,
    [?assertEqual({ok, Signature}, create_signature(Bin, Bin))
    ,?assertEqual({ok, Signature}, create_signature(Hex, Bin))
    ,?assertEqual({ok, Signature}, create_signature(Bin, Hex))
    ,?assertEqual({ok, Signature}, create_signature(Hex, Hex))
    ].

%%--------------------------------------------------------------------
%% @doc `verify/1' function verifies a nostr record or a raw parsed
%% JSON.
%%
%% @todo add a way to verify raw event as bitstring (JSON).
%% @end
%%--------------------------------------------------------------------
-spec verify(Event) -> Return when
      Event :: decoded_event(),
      Return :: boolean().

verify(#event{ id = Id
             , public_key = PublicKey
             , signature = Signature = _Event }) ->
    verify(Id, PublicKey, Signature);
verify(#{ <<"id">> := Id
        , <<"pubkey">> := PublicKey
        , <<"sig">> := Signature }) ->
    BinId = hex_to_binary(Id),
    BinPublicKey = hex_to_binary(PublicKey),
    BinSignature = hex_to_binary(Signature),
    verify(BinId, BinPublicKey, BinSignature).

%%--------------------------------------------------------------------
%% @doc `verify/3'
%% @end
%%--------------------------------------------------------------------
-spec verify(EventId, PublicKey, Signature) -> Return when
      EventId :: decoded_event_id(),
      PublicKey :: decoded_public_key(),
      Signature :: decoded_signature(),
      Return :: boolean().

verify(BinId, BinPublicKey, BinSignature) ->
    nostrlib_schnorr:verify(BinId, BinPublicKey, BinSignature).

%%--------------------------------------------------------------------
%% @doc `sign/2'
%% @end
%%--------------------------------------------------------------------
-spec sign(Event, PrivateKey) -> Event when
      PrivateKey :: decoded_private_key(),
      Event :: {ok, event()}.

sign(#event{ id = undefined } = Event, PrivateKey) ->
    case create_id(Event) of
        {ok, Id} -> sign(Event#event{ id = Id }, PrivateKey);
        Elsewise -> Elsewise
    end;
sign(#event{ id = <<Id:256/bitstring>> } = Event, PrivateKey) ->
    HexId = nostrlib:hex_to_binary(Id),
    {ok, RawSignature} = nostrlib_schnorr:sign(HexId, PrivateKey),
    HexSignature = nostrlib:binary_to_hex(RawSignature),
    Event#event{ signature = HexSignature }.

%%--------------------------------------------------------------------
%% @doc `check_tag/1' check if a `tag' is valid, like specified in
%% nip/01.
%%
%% @end
%%--------------------------------------------------------------------
-spec decode_tag(Tag) -> Return when
      Tag :: [iodata(), ...],
      Return :: {ok, Tag}
              | {error, proplists:proplists()}.

% public key tag
decode_tag([<<"p">>, <<PublicKey:512/bitstring>>]) ->
    T = #tag{ name = public_key
            , value = hex_to_binary(PublicKey)
            },
    {ok, T};
decode_tag([<<"p">>, <<PublicKey:512/bitstring>>, <<RecommendedRelayUrl/bitstring>>]) ->
    T = #tag{ name = public_key
            , value = hex_to_binary(PublicKey)
            , params = [RecommendedRelayUrl]
            },
    {ok, T};

% event id tag
decode_tag([<<"e">>, <<EventId:512/bitstring>>]) ->
    T = #tag{ name = event_id
            , value = hex_to_binary(EventId)
            },
    {ok, T};
decode_tag([<<"e">>, <<EventId:512/bitstring>>, <<RecommendedRelayUrl/bitstring>>]) ->
    T = #tag{ name = event_id
            , value = hex_to_binary(EventId)
            , params = [RecommendedRelayUrl]
            },
    {ok, T};

decode_tag(Tag) ->
    {error, [{tag, Tag}]}.

%%--------------------------------------------------------------------
%% @doc `check_tags/1' checks if a list of `tags' are valid.
%%
%% @end
%%--------------------------------------------------------------------
-spec decode_tags(Tags) -> Return when
      Tag :: [iodata(), ...],
      Tags :: [Tag, ...],
      Return :: {ok, Tags}
              | {error, proplists:proplists()}.

decode_tags(Tags) ->
    decode_tags(Tags, []).

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
decode_tags([], Buffer) ->
    {ok, lists:reverse(Buffer)};
decode_tags([Tag|Rest], Buffer) ->
    case decode_tag(Tag) of
        {ok, T} -> decode_tags(Rest, [T|Buffer]);
        Elsewise -> Elsewise
    end;
decode_tags(Tags, _) ->
    {error, [{tags, Tags}]}.

%%--------------------------------------------------------------------
%% @doc
%% @todo add more tests
%% @end
%%--------------------------------------------------------------------
-spec serialize(event()) -> list().
serialize(#{ <<"pubkey">> := <<PublicKey/binary>> })
  when byte_size(PublicKey) =/= 64 ->
    {error, [{public_key, PublicKey}]};
serialize(#{ <<"created_at">> := CreatedAt }) 
  when not is_integer(CreatedAt) orelse CreatedAt<0 ->
    {error, [{created_at, CreatedAt}]};
serialize(#{ <<"kind">> := Kind }) 
  when not is_integer(Kind) ->
    {error, [{kind, Kind}]};
serialize(#{ <<"tags">> := Tags }) 
  when not is_list(Tags) ->
    {error, [{tags, Tags}]};
serialize(#{ <<"content">> := Content })
  when not is_binary(Content) ->
    {error, [{content, Content}]};
serialize(#{ <<"pubkey">> := <<PublicKey:512/bitstring>>
           , <<"created_at">> := CreatedAt
           , <<"kind">> := Kind
           , <<"tags">> := Tags
           , <<"content">> := <<Content/bitstring>>
           } = _Event) ->
    Encoded = thoas:encode([0,PublicKey,CreatedAt,Kind,Tags,Content]),
    {ok, Encoded};
serialize(Event) ->
    {error, [{serialize, Event}]}.

% @hidden
-spec serialize_test() -> any().
serialize_test() ->
    [?assertEqual({error,[{created_at, -1}]}
                 ,serialize(#{ <<"created_at">> => -1 }))
    ,?assertEqual({error,[{kind, test}]}
                 ,serialize(#{ <<"kind">> => test }))
    ,?assertEqual({error,[{content, test}]}
                 ,serialize(#{ <<"content">> => test }))
    ,?assertEqual({error,[{tags, <<>>}]}
                 ,serialize(#{ <<"tags">> => <<>> }))
    ,?assertEqual({error,[{public_key, <<>>}]}
                 ,serialize(#{ <<"pubkey">> => <<>> }))
    ,?assertEqual({error,[{serialize, <<>>}]}
                 ,serialize(<<>>))
    ].
    

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
decode_subscription(<<SubscriptionId/binary>>, RawEvent, Labels) ->
    case decode_event_id(RawEvent, #event{}, []) of
        {ok, Event, EventLabels} ->
            Subscription = #subscription{ id = SubscriptionId
                                        , content = Event
                                        },
            {ok, Subscription, [EventLabels|Labels]};
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
decode_filters(Filter)
  when is_map(Filter) ->
    decode_filter(Filter);
decode_filters(Filters)
  when is_list(Filters)->
    decode_filters(Filters, []).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_filters([], Buffer) ->
    {ok, lists:reverse(Buffer)};
decode_filters([Filter|Rest], Buffer) ->
    case decode_filter(Filter) of
        {ok, F} -> decode_filters(Rest, [F|Buffer]);
        Elsewise -> Elsewise
    end.

% @hidden
-spec decode_filters_test() -> any().
decode_filters_test() ->
    [?assertEqual({ok, []}, decode_filters([]))
    ,?assertEqual({ok, #filter{}}, decode_filters(#{}))
    ,?assertEqual({ok, [#filter{}]}, decode_filters([#{}]))
    ].

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
decode_filter(Filter) ->
    decode_filter_check(Filter).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_filter_check(#{ <<"since">> := Since })
  when not is_integer(Since) orelse Since < 0 ->
    {error, [{since, Since}]};
decode_filter_check(#{ <<"until">> := Until })
  when not is_integer(Until) orelse Until < 0 ->
    {error, [{until, Until}]};
decode_filter_check(#{ <<"since">> := Since, <<"until">> := Until })
  when Since > Until ->
    {error, [{until, Until}, {since, Since}]};
decode_filter_check(#{ <<"limit">> := Limit })
  when not is_integer(Limit) orelse Limit < 0 ->
    {error, [{limit, Limit}]};
decode_filter_check(#{ <<"ids">> := EventsIds })
  when not is_list(EventsIds) ->
    {error, [{event_ids, EventsIds}]};
decode_filter_check(#{ <<"authors">> := Authors })
  when not is_list(Authors) ->
    {error, [{authors, Authors}]};
decode_filter_check(#{ <<"#e">> := TagEventIds })
  when not is_list(TagEventIds) ->
    {error, [{tag_event_ids, TagEventIds}]};
decode_filter_check(#{ <<"#p">> := TagPublicKeys })
  when not is_list(TagPublicKeys) ->
    {error, [{tag_public_keys, TagPublicKeys}]};
decode_filter_check(#{ <<"kinds">> := Kinds })
  when not is_list(Kinds) ->
    {error, [{kinds, Kinds}]};
decode_filter_check(Filter) ->
    decode_filter_ids(Filter, #filter{}).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
% @todo add decode prefixes for ids
decode_filter_ids(#{ <<"ids">> := EventIds } = Filter, Buffer)
  when is_list(EventIds) ->
    case decode_prefixes(EventIds) of
        {ok, Prefixes} ->
            Next = Buffer#filter{ event_ids = Prefixes },
            decode_filter_authors(Filter, Next);
        Elsewise ->
            Elsewise
    end;
decode_filter_ids(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_authors(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_prefixes(Prefixes) ->
    decode_prefixes(Prefixes, []).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_prefixes([], Buffer) -> {ok, lists:reverse(Buffer)};
decode_prefixes([Prefix|Rest], Buffer) ->
    case is_hex(Prefix) of
        true ->
            Decoded = hex_to_binary(Prefix),
            decode_prefixes(Rest, [Decoded|Buffer]);
        false ->
            {error, [{prefix, Prefix}]}
    end;
decode_prefixes(Prefixes,_) ->
    {error, [{prefixes, Prefixes}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
% @todo add decode prefixes for authors
decode_filter_authors(#{ <<"authors">> := Authors } = Filter, Buffer)
  when is_list(Authors) ->
    case decode_prefixes(Authors) of
        {ok, Prefixes} ->
            Next = Buffer#filter{ authors = Prefixes },
            decode_filter_kinds(Filter, Next);
        Elsewise -> Elsewise
    end;
decode_filter_authors(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_kinds(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_filter_kinds(#{ <<"kinds">> := Kinds } = Filter, Buffer) ->
    Next = Buffer#filter{ kinds = kinds(Kinds) },
    decode_filter_tag_event_ids(Filter, Next);
decode_filter_kinds(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_tag_event_ids(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
% @todo add decode for tags event ids
decode_filter_tag_event_ids(#{ <<"#e">> := TagEventIds } = Filter, Buffer) ->
    Parsed = lists:map(fun(X) -> hex_to_binary(X) end, TagEventIds),
    Next = Buffer#filter{ tag_event_ids = Parsed },
    decode_filter_tag_public_keys(Filter, Next);
decode_filter_tag_event_ids(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_tag_public_keys(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
% @todo add decode for tags public keys
decode_filter_tag_public_keys(#{ <<"#p">> := TagPublicKeys } = Filter, Buffer) ->
    Parsed = lists:map(fun(X) -> hex_to_binary(X) end, TagPublicKeys),
    Next = Buffer#filter{ tag_public_keys = Parsed },
    decode_filter_since(Filter, Next);
decode_filter_tag_public_keys(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_since(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_filter_since(#{ <<"since">> := Since } = Filter, Buffer) ->
    Next = Buffer#filter{ since = erlang:posixtime_to_universaltime(Since) },
    decode_filter_until(Filter, Next);
decode_filter_since(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_until(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_filter_until(#{ <<"until">> := Until } = Filter, Buffer) ->
    Next = Buffer#filter{ until = erlang:posixtime_to_universaltime(Until) },
    decode_filter_limit(Filter, Next);
decode_filter_until(Filter, Buffer)
  when is_map(Filter) ->
    decode_filter_limit(Filter, Buffer).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_filter_limit(#{ <<"limit">> := Limit } = _Filter, Buffer) ->
    {ok, Buffer#filter{ limit = Limit }};
decode_filter_limit(Filter, Buffer)
  when is_map(Filter) ->
    {ok, Buffer}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec decode_filter_test() -> any().
decode_filter_test() ->
    [?assertEqual({ok, #filter{}}, decode_filter(#{}))
    ,?assertEqual({ok, #filter{ since = {{2020,01,01}, {00,00,00}}
                              , until = {{2021,01,01}, {00,00,00}}
                              , limit = 100
                              }}
                 ,decode_filter(#{ <<"since">> => 1577836800
                                 , <<"until">> => 1609459200
                                 , <<"limit">> => 100
                                 })
                 )
    ].

%%--------------------------------------------------------------------
%% @hidden
%% @doc
%% @end
%%--------------------------------------------------------------------
decode_request(SubscriptionId, Filters, Labels) ->
    case decode_filters(Filters) of
        {ok, F} ->
            Request = #request{ subscription_id = SubscriptionId
                              , filter = F
                              },
            {ok, Request, Labels};
        Elsewise -> Elsewise
    end.

%%--------------------------------------------------------------------
%% @hidden
%% @doc
%% @end
%%--------------------------------------------------------------------
decode_eose(Value, Labels) ->
    case decode_subscription_id(Value) of
        {ok, SubscriptionId} ->
            Eose = #eose{ id = SubscriptionId },
            {ok, Eose, Labels};
        _Elsewise ->
            {error, [{eose, Value}]}
    end.

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
decode_notice(Value, Labels)
  when is_binary(Value) ->
    Notice = #notice{ message = Value },
    {ok, Notice, Labels};
decode_notice(Value, _Labels) ->
    {error, [{notice, Value}]}.

%%--------------------------------------------------------------------
%% @doc internal function.
%% @end
%%--------------------------------------------------------------------
decode_close(Value, Labels)
  when is_binary(Value) ->
    case decode_subscription_id(Value) of
        {ok, SubscriptionId} ->
            Close = #close{ subscription_id = SubscriptionId },
            {ok, Close, Labels};
        Elsewise -> Elsewise
    end;
decode_close(SubscriptionId, _Labels) ->
    {error, [{subscription_id, SubscriptionId}]}.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
decode_subscription_id(<<SubscriptionId/binary>>) ->
    case re:run(SubscriptionId, <<"^\\w+$">>) of
        {match, _} -> {ok, SubscriptionId};
        _ -> {error, [{subscription_id, SubscriptionId}]}
    end.

%%--------------------------------------------------------------------
%% @doc kind/1 function helps to convert nostr kind from atom to
%%      integer and integer from atom.
%% @end
%%--------------------------------------------------------------------
-spec kind(Kind) -> Return when
      Kind :: kind(),
      Return :: kind().

?KIND(0, set_metadata);
?KIND(1, text_note);
?KIND(2, recommend_server);
?KIND(3, contact_list);
?KIND(7, reaction);
kind(_) -> unsupported.

%%--------------------------------------------------------------------
%% @doc kinds/1 function converts a list of atoms into integers.
%% @end
%%--------------------------------------------------------------------
-spec kinds(Kinds) -> Return when
      Kinds :: kinds(),
      Return :: [pos_integer()].

kinds(Kinds) ->
    Converter = fun(Kind) when is_atom(Kind) -> kind(Kind);
                   (Kind) when is_integer(Kind) -> kind(Kind)
                end,
    lists:map(Converter, Kinds).

%%--------------------------------------------------------------------
%% @doc `integer_to_hex/1' converts integer to hexadecimal bitstring.
%%
%% @end
%%--------------------------------------------------------------------
-spec integer_to_hex(Integer) -> Hexadecimal when
      Integer :: pos_integer() | bitstring() | string(),
      Hexadecimal :: bitstring().

integer_to_hex(Integer)
  when is_integer(Integer) andalso Integer >= 0 ->
    << <<(char_to_lower(X))>> || <<X>> <= integer_to_binary(Integer, 16) >>;
integer_to_hex(List)
  when is_list(List) ->
    integer_to_hex(list_to_integer(List));
integer_to_hex(Bitstring)
  when is_bitstring(Bitstring) ->
    integer_to_hex(binary_to_integer(Bitstring)).

% @hidden
-spec integer_to_hex_test() -> any().
integer_to_hex_test() ->
    ?assertEqual(<<"0">>, integer_to_hex(0)),
    ?assertEqual(<<"0">>, integer_to_hex("0")),
    ?assertEqual(<<"0">>, integer_to_hex(<<"0">>)),
    ?assertEqual(<<"1">>, integer_to_hex(1)),
    ?assertEqual(<<"1">>, integer_to_hex("1")),
    ?assertEqual(<<"1">>, integer_to_hex(<<"1">>)),
    ?assertEqual(<<"f">>, integer_to_hex(15)),
    ?assertEqual(<<"f">>, integer_to_hex("15")),
    ?assertEqual(<<"f">>, integer_to_hex(<<"15">>)),
    ?assertEqual(<<"ffff">>, integer_to_hex(65535)),
    ?assertEqual(<<"ffff">>, integer_to_hex("65535")),
    ?assertEqual(<<"ffff">>, integer_to_hex(<<"65535">>)),
    ?assertEqual(<<"ffffffff">>, integer_to_hex(4294967295)),
    ?assertEqual(<<"ffffffff">>, integer_to_hex("4294967295")),
    ?assertEqual(<<"ffffffff">>, integer_to_hex(<<"4294967295">>)),
    ?assertEqual(<<"5132e8bf2ac08dc03016dda748ab8c9c1207d595afb35b87539413b99932ad72">>
                ,integer_to_hex(36727289447488093764767047625565761236828060469984325220555173745007757798770)).

%%--------------------------------------------------------------------
%% @doc `hex_to_integer/1' converts an hexadecimal bitstring to
%% integer. It's a wrapper around `erlang:binary_to_integer/1'
%% function.
%%
%% @see erlang:binary_to_integer/2
%% @end
%%--------------------------------------------------------------------
-spec hex_to_integer(Hexadecimal) -> Integer when
      Hexadecimal :: bitstring(),
      Integer :: pos_integer() | bitstring() | string().

hex_to_integer(Hexadecimal) ->
    erlang:binary_to_integer(Hexadecimal, 16).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec hex_to_integer_test() -> any().
hex_to_integer_test() ->
    [?assertEqual(36727289447488093764767047625565761236828060469984325220555173745007757798770
                 ,hex_to_integer(<<"5132e8bf2ac08dc03016dda748ab8c9c1207d595afb35b87539413b99932ad72">>))
    ].

%%--------------------------------------------------------------------
%% @doc `binary_to_hex/1' converts a raw bitstring to hexadecimal
%% string.
%%
%% @end
%%--------------------------------------------------------------------
-spec binary_to_hex(Bitstring) -> Hexadecimal when
      Bitstring :: iodata(),
      Hexadecimal :: bitstring().

binary_to_hex(Bitstring) ->
    Convert = fun(Char) ->
                      <<Hex>> = integer_to_binary(Char, 16),
                      char_to_lower(Hex)
              end,
    << <<(Convert(X))>> || <<X:4>> <= Bitstring >>.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec binary_to_hex_test() -> any().
binary_to_hex_test() ->
    [?assertEqual(<<"0123456789abcdef">>
                 ,binary_to_hex(<< <<X:4>> || X <- lists:seq(0,15) >>))
    ,?assertEqual(<<"ffffffff">>
                 ,binary_to_hex(<< <<15:4>> || _ <- lists:seq(0,7) >>))
    ].

%%--------------------------------------------------------------------
%% @doc `hex_to_binary/1' converts an hexadecimal string to a raw
%% binary.
%%
%% == Examples ==
%%
%% ```
%% <<1,35,69,103,137,171,205,239>> = nostrlib:hex_to_binary(<<"0123456789abcdef">>).
%% '''
%%
%% @end
%%--------------------------------------------------------------------
-spec hex_to_binary(Hexadecimal) -> Binary when
      Hexadecimal :: binary(),
      Binary :: binary().

hex_to_binary(Hexadecimal) ->
    << <<(char_to_hex(X)):4>> || <<X>> <= Hexadecimal >>.

% @hidden
-spec hex_to_binary_test() -> any().
hex_to_binary_test() ->
    [?assertEqual(<<1,35,69,103,137,171,205,239>>
                 ,hex_to_binary(<<"0123456789abcdef">>))
    ,?assertEqual(<< <<15:4>> || _ <- lists:seq(0,7) >>
                 ,hex_to_binary(<<"ffffffff">>))
    ].

%%--------------------------------------------------------------------
%% @doc `is_hex/1' checks if an hex string is valid.
%%
%% == Examples ==
%%
%% ```
%% true = nostrlib:is_hex(<<"0123456789abcdef">>).
%% false = nostrlib:is_hex(<<"test">>).
%% '''
%%
%% @see check_hex/1
%% @end
%%--------------------------------------------------------------------
-spec is_hex(Hexadecimal) -> Return when
      Hexadecimal :: iodata(),
      Return :: boolean().

is_hex(Hexadecimal) ->
    case check_hex(Hexadecimal, <<>>) of
        {ok, _} -> true;
        {error, _} -> false
    end.

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec is_hex_test() -> any().
is_hex_test() ->
          [?assertEqual(true, is_hex(<<"0123456789abcdef">>))
          ,?assertEqual(false, is_hex(<<"test">>))
          ].

%%--------------------------------------------------------------------
%% @doc `check_hex/1' analyses the content of a supposed hexadecimal
%% bitstring and returns if it if valid, else returns the reason of
%% the problem. This function only accept lowercase hexadecimal.
%%
%% == Examples ==
%%
%% ```
%% {ok, <<"0123456789abcdef">>} = nostrlib:check_hex(<<"0123456789abcdef">>).
%%
%% {error,[{char,<<"_">>}
%%        ,{offset,10}
%%        ,{valid,<<"0123456789">>}
%%        ,{rest,<<"abcdef">>}] = check_hex(<<"0123456789_abcdef">>).
%% '''
%%
%% @end
%%--------------------------------------------------------------------
-spec check_hex(Hexadecimal) -> Return when
      Hexadecimal :: iodata(),
      Return :: {ok, Hexadecimal}
              | {error, proplists:proplists()}.

check_hex(Hexadecimal) ->
    check_hex(Hexadecimal, <<>>).

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec check_hex_test() -> any().
check_hex_test() ->
    [?assertEqual({ok, <<"0123456789abcdef">>}
                 ,check_hex(<<"0123456789abcdef">>))
    ,?assertEqual({error,[{char,<<"_">>},{offset,10},{valid,<<"0123456789">>},{rest,<<"abcdef">>}]}
                 ,check_hex(<<"0123456789_abcdef">>))
    ].

%%--------------------------------------------------------------------
%% @hidden
%%--------------------------------------------------------------------
-spec check_hex(Hexadecimal, Buffer) -> Return when
      Hexadecimal :: bitstring(),
      Buffer :: bitstring(),
      Return :: {ok, Hexadecimal}
              | {error, proplists:proplists()}.

check_hex(<<>>, Buffer) -> {ok, Buffer};
check_hex(<<Char:8, Rest/bitstring>>, Buffer)
  when Char >= $0 andalso Char =< $9 ->
    check_hex(Rest, <<Buffer/bitstring, Char>>);
check_hex(<<Char:8, Rest/bitstring>>, Buffer)
  when Char >= $a andalso Char =< $f ->
    check_hex(Rest, <<Buffer/bitstring, Char>>);
check_hex(<<Char:8/bitstring, Rest/bitstring>>, Buffer) ->
    Offset = byte_size(Buffer),
    Message = [{char, Char}, {offset, Offset}, {valid, Buffer}, {rest, Rest}],
    {error, Message};
check_hex(Value, Buffer) ->
    {error, [{value, Value}, {buffer, Buffer}]}.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function used to change uppercase hex to lowercase.
%% @end
%%--------------------------------------------------------------------
-spec char_to_lower(Integer) -> Integer when
      Integer :: pos_integer().

char_to_lower($A) -> $a;
char_to_lower($B) -> $b;
char_to_lower($C) -> $c;
char_to_lower($D) -> $d;
char_to_lower($E) -> $e;
char_to_lower($F) -> $f;
char_to_lower(Integer)
  when Integer >= $0 andalso Integer =< $9 ->
    Integer.

%%--------------------------------------------------------------------
%% @hidden
%% @doc internal function used to convert ASCII numbers to
%% integers. Accept only lowercase hexadecimal code.
%% @end
%%--------------------------------------------------------------------
-spec char_to_hex(Char) -> Integer when
      Char :: pos_integer(),
      Integer :: pos_integer().

char_to_hex($0) -> 0;
char_to_hex($1) -> 1;
char_to_hex($2) -> 2;
char_to_hex($3) -> 3;
char_to_hex($4) -> 4;
char_to_hex($5) -> 5;
char_to_hex($6) -> 6;
char_to_hex($7) -> 7;
char_to_hex($8) -> 8;
char_to_hex($9) -> 9;
char_to_hex($a) -> 10;
char_to_hex($b) -> 11;
char_to_hex($c) -> 12;
char_to_hex($d) -> 13;
char_to_hex($e) -> 14;
char_to_hex($f) -> 15.

%%--------------------------------------------------------------------
%% @doc `create_subscription_id/0' generate a new subscription id
%% based on `crypto:strong_rand_bytes/1'. It returns a base64 encoded
%% string.
%%
%% From the specification:
%%
%%    `<subscription_id>' is an arbitrary, non-empty string of max
%%    length `64' chars, that should be used to represent a
%%    subscription.
%%
%% == Examples ==
%%
%% ```
%% <<SubscriptionId:256/bitstring>> = nostrlib:new_subscription_id().
%% '''
%%
%% @todo use base32 string instead of base64.
%% @see crypto:strong_rand_bytes/1
%% @see base64:encode/1
%% @end
%%--------------------------------------------------------------------
-spec new_subscription_id() -> Return when
      Return :: bitstring().

new_subscription_id() ->
    base64:encode(crypto:strong_rand_bytes(24)).
