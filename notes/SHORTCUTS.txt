= SHORTCUTS SESSION

== 2023-09-05: Shortcut_24/01

Hey everyone! First shortcut of this new season. Sorry for the delay,
I was playing with another project but now is the time to code for
Erlang Punch and nostr I did only few small modification during the
past three months. I merged bech32 module (we'll see that in another
shortcut) and did some cleanup  but the project did not change a
lot. At least, we are still stuck on the same issues. Okay, let's
do that!

We were working on nip/05, I think had something that work, but we
will need to check that. Another project could be cool, something we
were talking on for many months: creating the message router. Oh!
I remember now! The link between nip/05 and the database was not
done. Do I want to work on that right now? Not sure. I don't even
remember how this part is working. Let start our pomodoro session.
No more talk ;)

Okay! We need a way to list active clients but it leads to...
database, in particular mnesia. Well, I feel hot to do some
mnesia! :)

So; first pomodoro done. I only updated some documentation and
started to play with mnesia. I don't really know how to deal
with the connection at this time. In fact, if we are starting
to use mnesia... Perhaps we should use it everywhere. I should
dissociate clients and users.

A client is an active connection to a server, and we should only have
one perhaps more if more users need to connect on it.

An user is using a client (so the connection) to receive and share
their information. In this case, we should have something like that:

 1. a new client is started, a client abstracts the connection
    between an user and the server.

 2. a new user want to use the connection/client, then it will share
    the same connection if it already exists or create it if not
    present.

 3. It become an active user.

Let works on the second part.

== 2023-09-05: Shortcut_24/02

Okay! That's the last one for tonight. It's hot out there, and it's
hard to think with this kind of weather. Adding mnesia is not a small
task and it will impact a lot of the implementation but based on the
big modification in many NIP, in particular NIP/01 and NIP/25, I will
need to use mnesia one day or another. What we did during these
shortcuts? Well... Documentation and a first step in the interface to
store clients state. That's a good thing for the first one.

 + created nostr@clients module
 + created interface to create, list and delete clients
 ~ added documentation
 ~ did some test to remember how this application was
   working...

See you next time friends; I need to drink some water. :')

== 2023-09-12: Shortcut_24/03

Hey everyone! Ready for a new shortcut session? Let's continue
working on nostr. Today, I was thinking on the current structure
of the application and all the mess I did during the last
shortcuts. I think I will merge all the previous branches
during the week and restart from a fresh branch. Anyway, last week
we were working with mnesia, we'll continue that for tonight.

  nostr_client_connection:start([{host, "nostr.sidnlabs.nl"}, {port, 443}]).

Okay, first session's over. When a new connection is created, its information
is now stored in mnesia (but also in process group). We don't want
to deal with the full id made of host, port, protocol (tls) and path, but
with want something to filter these elements from the database. This will
be the goal of the function `nostr@clients:get_client_by_host/1`.

I still think using process group and supervisor to store information could
be a good idea but it requires too much efforts. I will also probably
change the way arguments are passed. Instead of using proplists, I will
use some maps, better to do pattern matching, and more flexible.

 + can now list client
 + when connected, client is added in mnesia
 + when stopped, client is removed from mnesia
 ~ get client by hostname.
 ! change all datastructure used to pass argument

== 2023-09-12: Shortcut_24/04

I will stop for tonight. ~1h dedicated is enough. If I have
more time this week-end, perhaps doing a long session could
help me to fix all the mess I did :)

Anyway, we have now the function to get clients by their
hostname after a - very - long fight with match pattern,
a powerful feature, but hard to master. Next time, I use
`etf:fun2ms` to create a match pattern based on function!

 + create list_client_by_host/1
 ? the data structure used is not flexible enough.
 ! this module is dirty, a clean up is needed.

Well, it was a short live session, but I am also working
on other projects, and allocating 1h is already a bit
hard. If you are interested, I recently created an interface
using NIF to manage cozodb. To be honest, that's a really
nice project, and I will (perhaps) add it in nostr to
store data instead of mnesia. We'll see!

See you Friday for another paper session, if not, see
you next Tuesday! ;)

== 2023-09-19: Shortcut_24/05

We start this session earlier. Let continue to work on nostr! In this
session I clean up nostr_client_connection module I create months ago.
It was dirty and only for a PoC. A good program -- in my point of view
-- is made of small functions connected together, you can eventually
test on demand. Each steps are isolated and some errors can be
correctly designed. One function should only return one good result,
or at least not an infinity of results.

The state of the process should have only important information, but
in this case, I think I will play hard and store everything in it. The
goal is to have something working, not to optimize. If removing some
elements of the state is required, then we will do that in another
coding session.

== 2023-09-19: Shortcut_24/06

I will continue to clean up this code in this pomodoro. Every steps
are acting like a whole pipeline during the initialization
phase. Types are partially checked during this phase. notify functions
could be exported in another module to reuse this part of the code in
other modules. Only TLS connection is now supported, init_connection
function will need to be uncommented and updated like other functions.

clients are currently not removed from mnesia. It needs to be
uncommented as well. I think a delete notification can be created.

== 2023-09-19: Shortcut_24/07

Let continue! I will extend this session a little bit to understand
what happens to the host field in the state. It looks better! So, this
is over for tonight. We cleaned up nostr_client_client connection, but
this is not done yet. What's the idea behind that? Still put in its
one place each connection and isolated each elements. I need to
control a bit the data I'm sharing with this part of the code. Anyway,
interfaces did not change at all, so, that's cool! See you next week
for more nostr and erlang coding. ;)

== 2023-09-26: Shortcut_24/08

Starting in October, I will slow down the shortcut sessions and will
do something a bit different. It seems I'm more productive when I'm
not in live session (what a surprise). I will record my sessions
during 6 or 7h hours and then publish them one by one. I will probably
do the same for my others sessions. Doing lives with only few watchers
is not really motivating and quite time consuming. So, anyway, let
start this new shortcut session.

As you can see I started to do some helpers for mnesia, and modify
few part of the code just before starting this live. I will continue
to do that. Another reason why I really need to work like 6h00, I
will redo the whole structure of this solution by using mnesia
instead of the current method I'm using.

Created a small way to store all certificates in mnesia table. We will
use it as reference in all other configuration, it will be easier to
debug.

== 2023-09-26: Shortcut_24/09

Ah! My client does not work anymore! \o/

So, I think I will redo everything from scratch. This code is too
complex and nip/01 was also deeply modified. Wanna see how to
destroy a project? :D

Okay. I don't know why I did that. Each things should be totally
isolated, that the case, but the way to get each information is
goddamn hard. A graphical interface could perhaps help here :')

So, we have our clients connects. We need to have our users available
and create a link between them. Renaming those table could help as
well. We are using a client, so, it should be nostr_client and not
just nostr.

To me, the connection is simply dropped. I will stop for tonight and
will clean this mess. To much issues. The main bricks should be
operational, but the way I'm plugging everything together is
bad. I should have started by using mnesia at first instead of
storing everything in Args. Anyway, it's hard to stay focus only
few hours by week! We will fix that next time :)

== 2023-09-26: Shortcut_24/10

Finally, I continue! The problem is from the routering part, I think
this part only work when started with the full client process. That's
not the case here though. Okay, I'm stuck for tonight. I would like to
add a kind of callback somewhere but this connection is really raw,
and I have no ways to easily deal with those kind of message, except
if I forward them to a parser, router or something like that.

I will recreate something easier; next time I will implement a
simple message store coming from the server: it will be a mnesia
table. Not sure if it will solve everything, but if I have a
moment this week-end, I will probably remove half of the current
structure. Don't worry, it will be recorded! :D

See you soon! ;)

== 2023-10-01: Shortcut_24/11

Hi folks! Today, we will do some cleanup. The room is messy, I need to
clean my mess. The idea is to do a big review by myself, convert this
application into a release, and document stuff. It will be a long
process and it will probably take the whole day. Let begins with
the application conversion to release.

So, in ~25minutes we converted nostr monolytic application to an
Erlang releases. Now, nostr, nostr_client, nostr_relay and bech32 are
isolated application. It will be easier to export and reuse them in
other projects.

== 2023-10-01: Shortcut_24/12

Cleanup is not over yet, few modifications are required and tests must
be successful. The next step will be to re-read all files and remove
what's not necessary but also creating applications files and
application process for each erlang applications.

== 2023-10-01: Shortcut_24/13

The whole application is working correctly. The last part is to move
nostrlib. This one will be a dependency for all nostr projects. It
looks good. The tests are okay (but will need to be modified as well
in a near future), and the applications are "working". Let works on
the real stuff now.

When an user want to connect to a server, he will use a client. This
client will be in charge of the connection to the relay and to forward
the events in the right format to the user. That's basically a
router. To avoid all the complexity right now, we will just create a
queue where all events from the relay will be stored using ETS or
mnesia.

Note: I will also change my way of doing this application, every part
MUST be independant and isolated. If I want my own connection with
users I can spawn it.

The connection state will be stored in mnesia as well. I don't care
anymore to store these information in this process. It's hard to debug
and not particularly useful.

Okay. I need a break. A quick summary, erlang_connection_connection
will have its own dedicated mnesia table containing all available
connections. The next step, is to modify the way I'm passing argument,
I will remove proplists and use maps. I will also convert it to
gen_statem. The forward key has been added to its record to forward by
default to the process called nostr_client_router.

== 2023-10-01: Shortcut_24/14

Back again! During lunch I was just testing some configuration. I
think I'm missing something somewhere. Let do a recap

 - an user can be connected to one or many relay
 - an user can subscribe to events on one or many relay

perhaps keeping the whole events locally could be a good idea? By
default, a relay does not send anything, and an user must subcribe to
a topic to receive events. When doing that, a random identifier is
generated and relays should and answers with messages tagged with this
id, if not, this is a notification from the server.

So the a router will do the mapping between the user, the connection
and the id. Why using a pid if we can use mnesia? The user name is
then the primary key of nostr_client_user table. The messages are then
stored in another table, nostr_client_messages, where the key is the
user id... In the next pomodoro, I will need to create some example
and demo to try that.

I really want to remove the complete nostr_client implementation and
start it again from scratch. Next step, convert
nostr_client_connection in gen_statem. We will do something easier.

== 2023-10-01: Shortcut_24/15

Started to convert nostr_client_connection to gen_statem. Not done
yet. It will now consist to test it and creates intermediate state. At
this time only disconnected and connected should be present.

== 2023-10-01: Shortcut_24/16

nostr_client_connection is now using gen_statem behavior and is
working correctly, at least with few open relays. pg groups should
also be modified, creating complex group names is not the best thing
to do. (just a quick modification on pg name).

== 2023-10-27: Shortcut_24_17

I will work on nostr_relay today, after having reviewed by code on
nostr_client, I think creating a router for nostr_relay will be
easier. In fact nostr_relay was just a PoC... So, there are not so
much features. Let do that.

nostr_relay is using cowboy with websocket support. When a client is
connecting to it, a new websocket is automatically opened using
nostr_relay_handler. Because we want to support multi-domain in a near
future, we will need to modify nostr_relay_listener. This module is
containing cowboy configuration. As you can see,
`nostr_relay_listener:routes/1` is configuring the routes, this part
of the code will need to be modified. Instead of setting a fixed list
of routes, we will match all routes (and all domains) and we will
forward them to `nostr_relay_handler` module. This module will be in
charge of routing the messages received by the client (including
domain name and so on), and parse them correctly.

Now the question is, where nostr_relay will find these information? In
Mnesia. Everything will be stored in mnesia and it should be okay for
the moment.

Another question... how to add support for nips? Well, we will need to
craft a new dedicated behavior like `nostr_relay_nip`. When a new
behavior needs to be implemented, we would be able to create something
like `nostr_relay_nip_01` or `nostr_relay_nip_02`. Anyway, that's not
the topic for the moment. At first, we need to parse our messages and
forward/store them somewhere.

`websocket_client` module was created under `nostr_utils` application
to help create websocket connection from scratch. It will be easier to
test the server with that. In fact, I don't know if curl is supporting
websocket now... Not sure. Anyway, here we will have our own small
websocket to craft request and hack around.

== 2023-10-27: Shortcut_24_18

Let continue to work on this small websocket client. It works locally,
without TLS but has some issue with secure connection, probably
because no certificates are passed as arguments. So, it looks "good",
need to try it a little bit more...

== 2023-10-27: Shortcut_24_19

The small websocket client is looking great, but we need to test it
more, and check if it works on real world server. It works! We can now
connect to a server and craft our payloads! Let test with a
binary. Great, binary messages are not accepted by the remote
server. We can now create a small websocket server, to test our future
client. It should be flexible enough to allow some weird configuration
and input.

It seems we have something, but it does not work yet. We will improve
it in a second time.

== 2023-10-27: Shortcut_24_20

Let continue to work on our small websocket server. Okay! It looks
very good. I just need to fix a small annoying bug when we pass an url
with ending without "/". Great! We can now design our router based on
the nostr specification, perhaps adding few documentation can help...

A short relecture will be required before continuing this code, and I
need a longer break, tea time <3, by the way, we should also add few
simple test to be sure everything is working well.

== 2023-10-27: Shortcut_24_21

Let simulate a router using websocket_client and websocket_server
modules. Those messages should follow some format or be validated
somewhere. When we are receiving a message, this message needs to be
checked using different kind of methods, as a pipeline.

`websocket_server_filter` module will be our first guard, checking if
the message is correct or not. Don't forget this application will need
to support many domains and path, so, here, this is just an example of
usage. Trying to send binary data to the server is not supported and
returns a NOTICE message to the client. How to represent a pipeline?
As a list of activated modules from one enabled relay.

   [ {Module1, Param1}
   , {Module2, Param2}
   , {Module3, Param3} ]

Where `Module1` is a behavior and MUST return a valid data to pass to
the next module.

== 2023-10-27: Shortcut_24_22

Let just, at first, try to parse a request and store it somewhere when
valid. Okay, it works but I think I will read a bit all the updates
added to the specification (NIPs), just to be sure I'm not going into
the wall. For example, nip01 only support kind 0 and 1, a function
callback could be created like in a "filter" module, saying this
module only support a restricted list of Kinds.

  kinds() -> [0,1].

Same could be applied for events. Yeah, it looks like a plugin Elixir,
but I think I will need to make it less flexible (or not). We'll see
that later.

== 2023-10-27: Shortcut_24_23

We have an idea how things are working now but what's happening when
we send client like data? We should probably test that before doing
more improvement then we will deal with the storage part.

Just played around with mnesia to find the best way to store these
data. It should be good on the next pomodoro session.

== 2023-10-27: Shortcut_24_24

Let continue to work on mnesia table to store our data. Great! If an
event is already present in the database, we have now a message saying
that to the client. That's good, but not enough.

Let redesign this part of the code, it's becoming too complex.

== 2023-10-27: Shortcut_24_25

Let create some testing there to avoid using the shell. Our code is
currently working! It's not glorious at all because it lacks lot of
documentation and test, but at least, we can write an event in the
database.

OK message specifications are missing, it needs to be created and we
must have a way to encode/decode it properly.

== 2023-10-27: Shortcut_24_26

Let implement "OK" messages, message sent by relays to clients. The
encoding part is practically done... So, it looks very good! We have
implemented a lot of crazy stuff during the latest shortcuts. We will
continue in another one! :)

== 2023-10-28: Shortcut_24_27

Let continue to work on our websocket server model. I really would
like to have a kind of module system at the end of this pomodoro,
returning an issue if something goes wrong (notice) or continuing
until we reach something valid.

Creating a behavior is not an easy task, even more when you don't
really master the protocol. The idea here is to create a pipeline of
actions, each action will return one kind of data, and main loop will
be in charge of dealing with them. Offering the global state by
default is perhaps not the best idea, I should probaly split it in two
part, one local state for the execution (directly offered to the
callback) and one extra state with the "whole" view of the connection,
used for example, when we need to deal with low level features or fine
grained websocket interaction.

== 2023-10-28: Shortcut_24_28

Let continue to work on the pipeline execution and find a way to deal
with those "annoying" states. Let try with this really small subset of
nip01. We will just encode ok and notice messages, without altering
the global state. We now need to adapt websocket_server_filter... Or
create a new one.

We have something that just "work" only for a small subset, but it
"works". Let try to improve that. FYI, I don't think it will be a
quite performant implementation, but we will improve that later.

== 2023-10-28: Shortcut_24_29

In this session we will continue to test our nostr relay behavior. Let
write some test. Hmm, it looks like we have a small bug there, since
we added an explicit call to another module (to store data). Will try
to fix it before the next shortcut. It looks good! :)

== 2023-10-28: Shortcut_24_30

Our pipeline is working, it's just a first version, but I think we can
use it without problem. Let try to generate some data and insert them
into the database.

Events are correctly inserted! Let create the other response from
relay to client. At this time, without testing, it looks "good", but I
will need to create more test and specifications.

I would like to use mnesia by default, but on big server, I'm not sure
it will be a good idea, so, creating a kind of storage interface could
be quite helpful. Mnesia would be the main store to keep only daily or
hourly events (like a cache), others events will be stored on one or
many places (postgresql, buckets, filesystems...). This MUST be
flexible to allow encryption by default.

Next, I will need to think about multi-domain and path support. Stored
these information in a configuration file first (synchronized with
mnesia) can be a good start. We'll see that in another shortcut.

== 2023-10-28: Shortcut_24_31

We can now store event in a better way than before, but now, we need
to deal with subscription. Indeed, users want to have access to some
events! To be honest, I don't know how to do that right now with this
new method, let try doing something anyway... Let try to fetch a list
of events.

Hmm... It was a bit stupid to insert created_at as Erlang datetime
format, storing it as unix string would have been better there. I
really think this part of the code will need some TDD, because I
really don't know how to deal with the logic. What's happening if we
have a list of valid ids on the server but with a different timestamp
range?

Okay, we have lot of things to do there. Encoder/decoder for filters
don't seem correct at first glance for the server part. The code is
"working" but more is required. All the logic part needs to be
implemented. We'll see that in another shortcut!

== 2023-10-28: Shortcut_24_32

Back for another shortcut session. We need to correct how I store
created_at, instead of using Erlang notation, we will keep epoch one
(from unix). After that, we will work on an interface to filter/get
data, if we have time, we'll work with qlc.

I started to add labels for filters, as reminder, a label is a kind of
metadata used to give more information when decoding a payload, for
example the difference between since/until. This will be used to
create limits.

== 2023-10-28: Shortcut_24_33

Let continue to add filter labels then we will switch to data storage
and filtering. Now, we can have labels when decoding filters! It will
be quite useful. Note: I think I will find other bugs, this part of
the code is not completely tested.

To answer correctly to the client, I will need to alter global state
by adding, at least, the connection and the websocket reference.

== 2023-10-28: Shortcut_24_34

Let add http connection and websocket reference into the global
state. It seems we can't do that... Instead, I will need to create a
list of answers to return. I think I need a small break. I have some
difficulties to do something simple. Woohoo! It works! I need a small
break now, but next:

 - cleaning up a little bit this dirty method
 - create a subscription table where subscriptions are stored
 - one connection = many subscription
 - when a connection is terminated, susbscriptions are removed
 - and much more...

== 2023-10-28: Shortcut_24_35

It seems I don't need to create a table for subscriptions. Indeed,
because subscriptions are tighly linked to a connection, we can store
them directly in the websocket state, and set a small timer sending a
message every seconds to fetch latest values from subscriptions. It
will also be read-only, so, we can use mnesia:dirty_* functions. Let
try that.

Okay, it looks good and it could work. I don't know if it could
support an high amount of message though. It will require some tests
and benchmark here. Limitations will also be required, I think 10
subscriptions is a "correct" amount by default.

== 2023-10-28: Shortcut_24_36

Let document and try to find some bugs in our implementation. When
done, I think it will be the time to implement it in the real world
(in nostr_relay application).

Okay! It seems we have our skeleton for nip01 on the relay side. It
supports a small subset of all function. In fact, it has been
implemented in a test module, but the ideas are there. A big cleanup
will be required to remove useless stuff and perhaps a new one.

Lot of tests will be required, to check if it's working, but we have a
small websocket client now! It will be easier to craft a full test
suite and simulate real world environment.

Note: a quick update on websocket_info event management! :)

== 2023-10-28: Shortcut_24_37

Let continue to work on our websocket management. That's a bit
complicated, but we must find a solution to make it easier. We are
receiving two timers, that's "normal", my code is still quite
dirty... Or not? Weird behavior with timer, I will check that later.

websocket_info function can now forward specific messages to their own
modules instead of modifying directly websocket_server module. When a
callback message is received, websocket_info is called in the module
defined in the second element of the tuple.

What does it means for subscription? Well, that means we can deal with
all the subscription stuff directly in the module itself instead of
altering the main loop. websocket loop from websocket_server module
needs to be isolated in its own module though.

== 2023-10-28: Shortcut_24_38

Let redesign websocket_server_action_request with a better
subscription management.

We should also do the same for the terminate function, when a module
is present in the pipeline, terminate function must call them one by
one. It will imply something else: execution order. A subscription is
identified by an unique identifier per connection, a list is not
really useful there, and a map is better solution.

A timestamp is also required for each subscription, to have an idea
when it was executed for the last time. Indeed, if we are polling
them, the state must be updated with an information when the last
extract was made. We will need to manage the close feature now.

== 2023-10-28: Shortcut_24_39

Let continue on close message implementation. A client can now add a
new subscriptions and remove them. At first glance, it looks "good",
then we need to deal with the filters... And that's not the same
story! In fact, only events should be stored in the database,
subscriptions and other things like that are not useful, except if we
add a feature to store filters (when an user with a specific key
connect, he has his subscriptions back).

All the functions/steps created there are quite dirty and must be
cleaned. One module MUST manage its own state with a dedicated
function (documented if possible).

Another thought... What if when a module is activated (or present in
the pipeline), its name is automatically created with a default value
in the state? Or, like I said previously in other shortcut, create a
"module local state" and a "global state". The global state will stay
unmodified, only "module local state" could be modified.

This code should work:

  ```erlang
  websocket_server_action_store:start().
  r3:do(compile).
  rr(nostrlib).
  f().
  application:stop(ranch).
  application:start(ranch).
  {ok, S} = websocket_server:start("localhost", 8081).
  {ok, C} = websocket_client:start("ws://localhost:8081").
  {ok, E1} = nostrlib:encode(#event{ content = <<"test">>, kind = text_note}, [{private_key, <<1:256>>}]).
  {ok, E2} = nostrlib:encode(#event{ content = <<"test">>, kind = text_note}, [{private_key, <<2:256>>}]).
  {ok, E3} = nostrlib:encode(#event{ content = <<"test">>, kind = text_note}, [{private_key, <<3:256>>}]).
  {ok, E4} = nostrlib:encode(#event{ content = <<"test">>, kind = text_note}, [{private_key, <<4:256>>}]).
  [ websocket_client:send(C, binary_to_list(X)) || X <- [E1,E2,E3,E4] ].

  {ok, Req} = nostrlib:encode(#request{ subscription_id = <<"test">>, filter = #filter{ event_ids = [ <<1:256>>]} }).
  websocket_client:send(C, binary_to_list(Req)).

  {ok, Req2} = nostrlib:encode(#request{ subscription_id = <<"test2">>, filter = #filter{ event_ids = [ <<1:256>>]} }).
  websocket_client:send(C, binary_to_list(Req2)).

  {ok, Close} = nostrlib:encode(#close{ subscription_id = <<"test">> }).
  websocket_client:send(C, binary_to_list(Close)).
  {ok, Close2} = nostrlib:encode(#close{ subscription_id = <<"test2">> }).
  websocket_client:send(C, binary_to_list(Close2)).
  ```

== 2023-10-28: Shortcut_24_40

Debugging part on subscriptions update. Not really usefull to have
this timestamp on each requests... I think we can move it somewhere
else. We have a s* ton of code deduplication. Timer is not created
when we want to create a new subscription. It will be "funny" to clean
this mess! :')

Some bugs have been fixed, and the relay is starting to look great. I
hope I will have enough time to create a subset of the filtering
logic.

== 2023-10-28: Shortcut_24_41

We need to implement the logic part of the filters, for doing that, I
will create a new module to test it called nu_filter. It will be my
"simulation" module to break stuff. I will use a kind of TDD method
there, it will be easier and probably better. What we have, should
produce that, and so on.

We should probably use proper or another module to generate this kind
of annoying data. But it should be enough for the moment. We can then
generate a lot of data.

== 2023-11-18: Shortcut_24_42

Let continue to work on random event generation, to have a way to
check our server and create some test suites. (sorry, forgot to put
the pomodoro...). So we have a way to generate fixed events based on a
private key and fixed timestamp. Now, we can deal with the logic
behind the filtering. The best way to have something stable here is to
use TDD (test driven development). Because we will need to check many
different situations, TDD will offer enough flexibility to at least
found a good way to deal with the different path offered by our
implementation.

Furthermore, TDD will also challenge our internal API, if our code is
too complex, our tests will be complex as well, and we will need to
refactor it. Here, we have defined 3 new functions, one to filter a
list of events against a list of filters, another one to filter one
event against a list of filter, and the last one if to check if an
event match one filter. With this configuration, we could easily
insert this filtering into a guard, and if you already know QLC, you
will understand where I want to go.

== 2023-11-18: Shortcut_24_43

Let continue to work on our event/filter testing. Okay, we have now a
way to check the event ids present in the filter, but also the authors
(with their public key(s)). This is not optimized at all,
lists:filter/2 function will check the whole list. In fact, we must
return true when we match the value, or false if we continue until the
end of the list. Why creating to separate functions? Well, say we want
to limit the size of the filtering list, we can do it directly on the
parser, but also here. Those functions can have an optional field (in
the future) to pass fine grained options, per user for example

Next fields to check are kinds, tag_event_ids and tag_public_keys. We
will deal with since, until and limit later.

== 2023-11-18: Shortcut_24_44

Let continue to work on filtering test. Okay, that looks good. We have
now a dummy filter to filter events based on nostr spec. Few tests are
needed but it looks good. The big problem is when generating
events. Need to add tag support now... Or not for the moment (I think
I will need to create some function helpers there). Let switch to
since, until and limit.

I did a mistake when I read the specification. I mixed AND and OR when
dealing with lists of items in filters and list of filters. Need to
fix that.

== 2023-11-18: Shortcut_24_45

Some bug to fix. I probably did a mistake on the filter checks. I will
need to modify the filter specification. Indeed, "it can have the
following attributes" means some fields can be undefined, in this
case, the default data-structure used (record), should deal with that.

It was a bit more complicated than expected but it should now be
fixed. We also have now a practically complete random event generator
(only tags are now missing).

== 2023-11-18: Shortcut_24_46

Let check our new filter! It looks better, but I'm not sure if its the
behavior we are looking for. I will probably need to check other
implementation as well.

Great! We just finished to test event_ids, kinds, authors, since and
until fields for the filters. Tags and limits are the last one to
do. Unfortunately, I think I will need to check tags. Regarding limit,
but I need to implement the whole behavior.

== 2023-11-18: Shortcut_24_47
