= SHORTCUTS SESSION

== 2023-03-31: shortcut_23/01

So, why pomodoro? why shortcut? Well... I used pomodoro method many
time in the past and was always happy when developing using that. why
shortcut? I wanted "short circuit" but it was a bit too
long... Shortcut looks better!

A quick summary: we coded the supervisor for the nostr_relay
subscription, deployed it started it and created a simple interface to
forward the events. More is needed... But we will see that in another
shortcut episode! :)

== 2023-04-03: shortcut_23/02

So a short break.  I created the first relay_store handler, to store
data in mnesia backend. The idea is to create a behavior with the
commands to insert, delete, update and select information from the
database. Not ACID... CRUD! :')

Anyway, the goal is to offer some facilities to create those handlers
and extend easily the relay. Inserting an event or a subscription
should be easy on mnesia but also on any kind of database like
postgresql.

I think this module will be updated soon with more specification. At
least, it works to insert data in the database (events). The
subscription will also be inserted into the database but the procedure
will be a bit different...

== 2023-04-04: shortcut_23/03

So yesterday, we were working on relay store and a mnesia
backend. let's continue.

Found a bug in the encoder. Will fix it right now. Better!

Okay, we corrected a bug in the encoder and started to define a new
table called subscriptions. This table will contain a list of
subscription identifier (generated by the clients), the client
connected and a reference to a filter (probably another table). The
identifier should be a tuble {ClientIdentifier, Connection}.

== 2023-04-04: shortcut_23/04

We will probably work on another part of the code. We will finish
NIP/02 and merge it. At this time, the relay is doing to much things
and it was not planned at all. Let's work on NIP/02 and the client
tonight!

The problem we had was related related to the way we should receive
the answers from the relay... We will try to deal with that or switch
to another issue.

We already have a great implementation on the client, but we lack it
on the server side. I think it will be done another day. We will
switch to another issue.

Let's add the support for the key store. The idea is to store it
somewhere on the disk. To do that we can use many different
methods. Which one is the best? Well... At first, we will just export
the key on a file present in the filesystem. We will improve it later.

Okay, a nostr_client_key module has been created, it is currently not
started but the idea is to have one process per key. This process will
be in charge to save/update/export the private information stored for
one user identified by a name. At first, the private keys (and other
informations) will not be encrypted. It seems a bit crazy, but we need
to start with something simple.

This information should be stored outside of the database because it
should be easy to extract and easy to export.

== 2023-04-04: shortcut_23/05

What kind of messages we need to support there? Well. We need to:

 1. (cast) generate a new key
 2. (cast) store the key on the disk
 3. (cast) load the key from the disk (if present)
 4. (call) export it in different formats
    
The main function created there was the initialization part of
nostr_client_key.
    
== 2023-04-04: shortcut_23/06
    
finalizing the initialization part of the nostr_client_key module
using gen_server. This shortcut implemented a way to generate,
initialize, and store a key. More tests are required though.
    
So, it's over for tonight! 3 shortcuts, one module implemented. It
looks good :)
    
See you for the next ones ;)

== 2023-04-16: shortcut_23/07

 + cleaned up nostr_client_key interfaces
 + created nostr_client_key:export_metadata/1 as JSON
 + added comments on terminate/2 function
 ! tests are required

== 2023-04-16: shortcut_23/08

  + wrote tests for nostr_client_key:export_metadata
  + export the metadata with the private key
  + use a proplist to store the private key and the metdata
  + store the content of the private key + metadata as ETF
  + create a sync/1 to manually store the value of the keys
  ! need to test when a wrong file is present
  ! need to add a checksum somewhere to validate the integrity of the file
  ! need more documentation on these features.
  ! ensure the file generated is not corrupted

== 2023-04-16: shortcut_23/09

  + use a bitstring instead of atom in the proplist
  + fix a bug with the mode used for the file generated
  + create reload/1 function to reload the content of the file
  + added a bit of documentation
  + one file will be created for all shorcuts.
  ! tests should be added to ensure its working correctly
  ! need more documentation

== 2023-04-XX: shortcut_23/10
