= SHORTCUTS SESSION

== 2023-03-31: shortcut_23/01

So, why pomodoro? why shortcut? Well... I used pomodoro method many
time in the past and was always happy when developing using that. why
shortcut? I wanted "short circuit" but it was a bit too
long... Shortcut looks better!

A quick summary: we coded the supervisor for the nostr_relay
subscription, deployed it started it and created a simple interface to
forward the events. More is needed... But we will see that in another
shortcut episode! :)

== 2023-04-03: shortcut_23/02

So a short break.  I created the first relay_store handler, to store
data in mnesia backend. The idea is to create a behavior with the
commands to insert, delete, update and select information from the
database. Not ACID... CRUD! :')

Anyway, the goal is to offer some facilities to create those handlers
and extend easily the relay. Inserting an event or a subscription
should be easy on mnesia but also on any kind of database like
postgresql.

I think this module will be updated soon with more specification. At
least, it works to insert data in the database (events). The
subscription will also be inserted into the database but the procedure
will be a bit different...

== 2023-04-04: shortcut_23/03

So yesterday, we were working on relay store and a mnesia
backend. let's continue.

Found a bug in the encoder. Will fix it right now. Better!

Okay, we corrected a bug in the encoder and started to define a new
table called subscriptions. This table will contain a list of
subscription identifier (generated by the clients), the client
connected and a reference to a filter (probably another table). The
identifier should be a tuble {ClientIdentifier, Connection}.

== 2023-04-04: shortcut_23/04

We will probably work on another part of the code. We will finish
NIP/02 and merge it. At this time, the relay is doing to much things
and it was not planned at all. Let's work on NIP/02 and the client
tonight!

The problem we had was related related to the way we should receive
the answers from the relay... We will try to deal with that or switch
to another issue.

We already have a great implementation on the client, but we lack it
on the server side. I think it will be done another day. We will
switch to another issue.

Let's add the support for the key store. The idea is to store it
somewhere on the disk. To do that we can use many different
methods. Which one is the best? Well... At first, we will just export
the key on a file present in the filesystem. We will improve it later.

Okay, a nostr_client_key module has been created, it is currently not
started but the idea is to have one process per key. This process will
be in charge to save/update/export the private information stored for
one user identified by a name. At first, the private keys (and other
informations) will not be encrypted. It seems a bit crazy, but we need
to start with something simple.

This information should be stored outside of the database because it
should be easy to extract and easy to export.

== 2023-04-04: shortcut_23/05

What kind of messages we need to support there? Well. We need to:

 1. (cast) generate a new key
 2. (cast) store the key on the disk
 3. (cast) load the key from the disk (if present)
 4. (call) export it in different formats
    
The main function created there was the initialization part of
nostr_client_key.
    
== 2023-04-04: shortcut_23/06
    
finalizing the initialization part of the nostr_client_key module
using gen_server. This shortcut implemented a way to generate,
initialize, and store a key. More tests are required though.
    
So, it's over for tonight! 3 shortcuts, one module implemented. It
looks good :)
    
See you for the next ones ;)

== 2023-04-16: shortcut_23/07

 + cleaned up nostr_client_key interfaces
 + created nostr_client_key:export_metadata/1 as JSON
 + added comments on terminate/2 function
 ! tests are required

== 2023-04-16: shortcut_23/08

  + wrote tests for nostr_client_key:export_metadata
  + export the metadata with the private key
  + use a proplist to store the private key and the metdata
  + store the content of the private key + metadata as ETF
  + create a sync/1 to manually store the value of the keys
  ! need to test when a wrong file is present
  ! need to add a checksum somewhere to validate the integrity of the file
  ! need more documentation on these features.
  ! ensure the file generated is not corrupted

== 2023-04-16: shortcut_23/09

  + use a bitstring instead of atom in the proplist
  + fix a bug with the mode used for the file generated
  + create reload/1 function to reload the content of the file
  + added a bit of documentation
  + one file will be created for all shorcuts.
  ! tests should be added to ensure its working correctly
  ! need more documentation

== 2023-04-18: shortcut_23/10

Hey everyone! Another shortcut tonight. I will try to continue
upgrading and cleaning up nostr_client_key module. Lot of todo
to fix and I think it will be okay. Let's do it!

 + added nostr_client_key test for sync/1
 + added nostr_client_key test for reload/1
 + added nostr_client_key process into nostr_client_sup tree
 + added pg support for nostr_client_key
 + fixed few typo in the code
 ! ensure nostr_client_key is corrected started
 ! cleanup the way init arguments are checked
 ! add documentation (again)

== 2023-04-18: shortcut_23/11

 + modified the record datastructure for nostr_client_key
   by adding the host of the connected server
 + created nostr_client:disconnect/1 function
 + create nostr_client_key:send_metadata/1 function to
   send the metadata directly to the connected server.
 ! an interface to send direct message to a connection is
   required, like nostr_client:send/X.
 ! nostr_client module documentation is missing
 ! nostr_client is not tested, need to add integration test
 ! the process identifiers are not good, we should use the
   name of the module and not create an atom like 'connection'.

== 2023-04-18: shortcut_23/12

I think it will be the last one. I will fix the bugs, cleanup
my mess and will upload all the videos on youtube ;)

 + tested nostr_client_key:send_metadata/1 function
 + created nostr_client_key:generate_metadata_event/1 to
   generate a set_metadata event based on the server state
 + create nostr_client:send/3 function to send a message to
   connected and active server
 + added few checks and error logging
 + updated the documentation (just a bit)
 + added notes and todos
 ! data contained in nostr_client_key should not be printed
   this module contains highly private data.
 ! a way more "conventional" way is needed to write the
   documentation. needs to define that someday.

Okay, 2minutes remaining. I think nostr_client_key module is
practically done. A big part of the things I am doing is related
to the integration of this module/process in the project. More
tests are needed though, and the way the messages are logged
is not good enough. Anyway, I will continue that during the next
shortcut session!

== 2023-04-25: Shortcut_23/13

Hi everyone! Shorcut 23/13 today. So, I will review a little bit what
I did last week on nostr_client_key module and try to find something
to do. Let's go!

 + synchronize keys after module nostr_client_key terminates.
 + added logging function in nostr_client_key
 + added a way to check the file mode for the private key
 ! wrong timer used, the pomodoro is a bit longer than usual

== 2023-04-25: Shortcut_23/14

 + create nostr client key store notes.
 + cleanup nostr client contacts module
 + add more documentation on nostr client contacts module
 - commented nostr_client_contacts:import/2 function.
 ? lot of questions to answer...

== 2023-04-25: Shortcut_23/15

Prepare nip/05 (see
https://github.com/nostr-protocol/nips/blob/master/05.md)

 + added check_nip05/1 function in nostr_client_key module
   to check the value of the identifier used. This element
   will be stored in the set_metadata event. That's a
   draft.
 ! creates the check function for the nip05 localpart
 ! creates the check function for the nip05 domain part
 ! creates test and documentation on this part of the code
 ? an external process should be in charge to fetch the
   result from the remote server and validate it.

Anyway! That was the last shortcut for tonight. We will continue to
work on that during the next days. See you! :)

== 2023-05-02: Shortcut_23/16

Continue to implement nip/05 for DNS authentication. Let's go!

 + created a new module called nostrlib_nip05
 + created nostrlib_05:target/1
 + created nostrlib_05:url/1
 + created nostrlib_05:get/1
 ! need to modify the way we managed the URL and the URI.
 ! need more documentation and some tests there...
 ? what kind of data structure should we use there

== 2023-05-02: Shortcut_23/17

 ~ nostrlib_nip05 is now using a gen_statem behavior for many reasons:
   (1) nip05 will check an external resources and should be isolated
   from the rest of the application (2) it's probably a one time event
   to ensure the user exist and is valid (3) when done, we should call
   it only and demand. This is the definition of finite state machine,
   we are waiting for an answer and will return it to another process,
   in our case, probably nostr_client_key (or another one).
 ! continue to implement nostrlib_nip05, this currently a draft.

== 2023-05-02: Shortcut_23/18

 + created states functions to deal with the data from the server
   hosting the information about the identifier, it needs to be
   improved but the idea is to split the actions in different isolated
   states.
 ! add certificate support when gun connects to a remote server
 ! creates a local test server to check if the process is correctly
   working
 ! add tests
 ! improvate the gen_statem state, it should contain:
   (1) connection attempts
   (2) if a failure, the reason
   (3) the state of the identifier (valid or not, the key id and so on...)
 ? How to deal with the errors there? Should we catch them?
 ? the done state should probably offers a way to switch in the wait
   mode in case of failure.

I think this shortcut session is over for tonight! unfortunately,
working on a draft is not really great... That's also why I wanted to
do these small session. Designing something is hard, and I did not
even really tested this application in real life! Anyway, see you for
the next shortcuts, have a great week! :)


